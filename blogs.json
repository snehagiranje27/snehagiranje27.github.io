{"status":"ok","feed":{"url":"https://medium.com/feed/@@snehagiranje05","title":"Stories by Snehagiranje on Medium","link":"https://medium.com/@snehagiranje05?source=rss-fcc1a302fb6e------2","author":"","description":"Stories by Snehagiranje on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/0*8VzN5Gc-qIB2t3xz"},"items":[{"title":"EKS on AWS vs Standalone Kubernetes","pubDate":"2024-10-13 02:07:24","link":"https://medium.com/@snehagiranje05/eks-on-aws-vs-standalone-kubernetes-fbcf2e3eb0f8?source=rss-fcc1a302fb6e------2","guid":"https://medium.com/p/fbcf2e3eb0f8","author":"Snehagiranje","thumbnail":"","description":"\n<p>In today\u2019s fast-paced tech world, containerization has become a go-to solution for deploying and managing applications. At the heart of this revolution lies Kubernetes, a powerful orchestration tool. But when it comes to implementation, developers often find themselves at a crossroads: should they opt for Amazon\u2019s Elastic Kubernetes Service (EKS) or set up Kubernetes on their own? Let\u2019s dive in and explore both\u00a0options.</p>\n<h4><strong>1. Introduction to Kubernetes and\u00a0EKS</strong></h4>\n<p><strong>Kubernetes</strong>, originally developed by Google, is an open-source platform that automates the deployment, scaling, and management of containerized applications. It organizes containers into logical units, simplifying their management and discovery.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/589/1*uzE_B0mXhy4x_aCGKDcyVw.png\"></figure><p><strong>Amazon Elastic Kubernetes Service (EKS)</strong> is AWS\u2019s fully managed Kubernetes service. It streamlines the process of running Kubernetes on AWS by handling much of the operational overhead, allowing developers to focus more on building applications and less on managing infrastructure.</p>\n<h4><strong>2. EKS vs Standalone Kubernetes: The Key Differences</strong></h4>\n<p><em>Management and Operations:</em> <strong><br></strong>Standalone Kubernetes: You\u2019re the head chef and kitchen manager. You handle everything from setting up the kitchen to managing staff schedules.<br>EKS: AWS acts as your kitchen manager, handling the backend operations while you focus on creating great\u00a0dishes.</p>\n<p><em>Integration with Cloud Services:</em><br>Standalone Kubernetes: You need to manually integrate any additional services you need, which can be time-consuming.<br>EKS: Seamlessly integrates with other AWS services like load balancers, IAM for security, and CloudWatch for monitoring.</p>\n<p><em>Cost Considerations:</em><br>Standalone Kubernetes: Potentially lower upfront costs, but factor in the time and resources for management.<br>EKS: Comes with a management fee, but can be cost-effective when considering the reduced operational burden.</p>\n<p><em>Scalability and Availability:</em><br>Standalone Kubernetes: Scalability depends on your setup and resources.<br>EKS: Leverages AWS\u2019s robust infrastructure for better scalability and availability across multiple\u00a0zones.</p>\n<h4>3. Choosing the Right\u00a0Option</h4>\n<p>Your choice between EKS and standalone Kubernetes should be guided by your specific\u00a0needs:</p>\n<p>Choose Standalone Kubernetes if:<br> 1. You need maximum control and customization.<br> 2. You\u2019re deploying across multiple cloud providers or on-premises.<br> 3. You have the expertise and resources for hands-on management.</p>\n<p>Opt for EKS if:<br> 1. You want to reduce operational overhead.<br> 2. Seamless integration with AWS services is crucial for your project.<br> 3. You prefer a managed service that handles updates and\u00a0scaling.</p>\n<h4>4. Conclusion</h4>\n<p>Both EKS and standalone Kubernetes offer powerful solutions for container orchestration. EKS provides a managed, integrated experience within the AWS ecosystem, while standalone Kubernetes offers more control and flexibility. Assess your project requirements, team expertise, and long-term goals to make the best choice for your\u00a0needs.</p>\n<p>Remember, the goal is to create a robust, scalable environment for your applications. Whether you choose to be the head chef managing every aspect of your kitchen or bring in AWS as your kitchen manager, ensure your choice aligns with your team\u2019s capabilities and your project\u2019s demands.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fbcf2e3eb0f8\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>In today\u2019s fast-paced tech world, containerization has become a go-to solution for deploying and managing applications. At the heart of this revolution lies Kubernetes, a powerful orchestration tool. But when it comes to implementation, developers often find themselves at a crossroads: should they opt for Amazon\u2019s Elastic Kubernetes Service (EKS) or set up Kubernetes on their own? Let\u2019s dive in and explore both\u00a0options.</p>\n<h4><strong>1. Introduction to Kubernetes and\u00a0EKS</strong></h4>\n<p><strong>Kubernetes</strong>, originally developed by Google, is an open-source platform that automates the deployment, scaling, and management of containerized applications. It organizes containers into logical units, simplifying their management and discovery.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/589/1*uzE_B0mXhy4x_aCGKDcyVw.png\"></figure><p><strong>Amazon Elastic Kubernetes Service (EKS)</strong> is AWS\u2019s fully managed Kubernetes service. It streamlines the process of running Kubernetes on AWS by handling much of the operational overhead, allowing developers to focus more on building applications and less on managing infrastructure.</p>\n<h4><strong>2. EKS vs Standalone Kubernetes: The Key Differences</strong></h4>\n<p><em>Management and Operations:</em> <strong><br></strong>Standalone Kubernetes: You\u2019re the head chef and kitchen manager. You handle everything from setting up the kitchen to managing staff schedules.<br>EKS: AWS acts as your kitchen manager, handling the backend operations while you focus on creating great\u00a0dishes.</p>\n<p><em>Integration with Cloud Services:</em><br>Standalone Kubernetes: You need to manually integrate any additional services you need, which can be time-consuming.<br>EKS: Seamlessly integrates with other AWS services like load balancers, IAM for security, and CloudWatch for monitoring.</p>\n<p><em>Cost Considerations:</em><br>Standalone Kubernetes: Potentially lower upfront costs, but factor in the time and resources for management.<br>EKS: Comes with a management fee, but can be cost-effective when considering the reduced operational burden.</p>\n<p><em>Scalability and Availability:</em><br>Standalone Kubernetes: Scalability depends on your setup and resources.<br>EKS: Leverages AWS\u2019s robust infrastructure for better scalability and availability across multiple\u00a0zones.</p>\n<h4>3. Choosing the Right\u00a0Option</h4>\n<p>Your choice between EKS and standalone Kubernetes should be guided by your specific\u00a0needs:</p>\n<p>Choose Standalone Kubernetes if:<br> 1. You need maximum control and customization.<br> 2. You\u2019re deploying across multiple cloud providers or on-premises.<br> 3. You have the expertise and resources for hands-on management.</p>\n<p>Opt for EKS if:<br> 1. You want to reduce operational overhead.<br> 2. Seamless integration with AWS services is crucial for your project.<br> 3. You prefer a managed service that handles updates and\u00a0scaling.</p>\n<h4>4. Conclusion</h4>\n<p>Both EKS and standalone Kubernetes offer powerful solutions for container orchestration. EKS provides a managed, integrated experience within the AWS ecosystem, while standalone Kubernetes offers more control and flexibility. Assess your project requirements, team expertise, and long-term goals to make the best choice for your\u00a0needs.</p>\n<p>Remember, the goal is to create a robust, scalable environment for your applications. Whether you choose to be the head chef managing every aspect of your kitchen or bring in AWS as your kitchen manager, ensure your choice aligns with your team\u2019s capabilities and your project\u2019s demands.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=fbcf2e3eb0f8\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]},{"title":"Mastering System Design: Day 3\u200a\u2014\u200aBuilding Blocks for Modern System Design","pubDate":"2024-07-22 20:43:11","link":"https://medium.com/@snehagiranje05/mastering-system-design-day-3-building-blocks-for-modern-system-design-836b7211b8a1?source=rss-fcc1a302fb6e------2","guid":"https://medium.com/p/836b7211b8a1","author":"Snehagiranje","thumbnail":"","description":"\n<h3>Mastering System Design: Day 3\u200a\u2014\u200aBuilding Blocks for Modern System\u00a0Design</h3>\n<p>Welcome back to Day 3 of our system design journey! Today, we explore the building blocks of modern system design, much like using Lego pieces to create intricate and powerful structures. Let\u2019s dive into how these fundamental components come together to form robust, scalable\u00a0systems.</p>\n<h3>Introduction to Building Blocks for Modern System\u00a0Design</h3>\n<h3>The Bottom-Up Approach to System\u00a0Design</h3>\n<p>System design problems often share similarities, though their specific details may vary. By identifying and standardizing these common components, we can streamline the design process. Think of these components as Lego bricks, which can be reused and rearranged to build various\u00a0systems.</p>\n<p>The purpose of separating building blocks is to discuss their design thoroughly once. This means that later we can use them anywhere without having to go over them in detail again. This modular approach allows for the construction of more effective, capable\u00a0systems.</p>\n<p>Many of these building blocks are available for use in public clouds like Amazon Web Services (AWS), Azure, and Google Cloud Platform (GCP). While we won\u2019t build these systems in this course, you can use these constructs to cement your understanding.</p>\n<h3>Using Building Blocks to Devise a Bottom-Up Approach</h3>\n<p>By understanding and utilizing these building blocks, we can tackle system design problems from the ground up, ensuring a solid foundation. Here are the key building blocks we\u2019ll cover in\u00a0detail:</p>\n<h3>Domain Name System\u00a0(DNS)</h3>\n<p>This building block focuses on designing hierarchical and distributed naming systems for computers connected to the Internet via different protocols. DNS translates human-readable domain names into IP addresses, facilitating communication between\u00a0devices.</p>\n<h3>Load Balancers</h3>\n<p>Load balancers distribute incoming client requests among a pool of available servers, ensuring no single server is overwhelmed. This component enhances system reliability and availability by managing traffic and bypassing failed\u00a0servers.</p>\n<h3>Databases</h3>\n<p>Databases store, retrieve, modify, and delete data in connection with various data-processing procedures. We\u2019ll discuss different database types, replication, partitioning, and the analysis of distributed databases to understand how they handle large-scale data.</p>\n<h3>Key-Value Store</h3>\n<p>A key-value store is a non-relational database that stores data in key-value pairs. This building block is essential for achieving scalability, durability, and configurability in systems that require quick access to\u00a0data.</p>\n<h3>Content Delivery Network\u00a0(CDN)</h3>\n<p>CDNs keep viral content such as videos, images, audio, and web pages close to end users, reducing latency and the burden on data centers. We\u2019ll explore how CDNs efficiently deliver content to users around the\u00a0world.</p>\n<h3>Sequencer</h3>\n<p>Sequencers generate unique IDs, maintaining causality in distributed systems. We\u2019ll examine three different methods for generating unique IDs, ensuring consistency and order in data processing.</p>\n<h3>Service Monitoring</h3>\n<p>Monitoring systems analyze the system and alert stakeholders if issues arise. We\u2019ll build two monitoring systems: one for server-side errors and another for client-side errors, providing early warning and proactive management of potential problems.</p>\n<h3>Distributed Caching</h3>\n<p>Distributed caching involves multiple cache servers coordinating to store frequently accessed data. This component enhances system performance by reducing the load on primary data\u00a0stores.</p>\n<h3>Distributed Messaging Queue</h3>\n<p>A distributed messaging queue decouples interacting entities (producers and consumers), allowing independent scalability and enhanced reliability. We\u2019ll explore how this component facilitates asynchronous communication between services.</p>\n<h3>Publish-Subscribe System (Pub-Sub)</h3>\n<p>Pub-Sub systems enable asynchronous service-to-service communication, popular in serverless, microservices architectures, and data processing systems. We\u2019ll design a robust pub-sub system to handle various messaging needs.</p>\n<h3>Rate Limiter</h3>\n<p>Rate limiters throttle incoming requests based on predefined limits, protecting services from excessive usage. This defensive layer ensures system stability and prevents\u00a0abuse.</p>\n<h3>Blob Store</h3>\n<p>Blob stores provide storage solutions for unstructured data, such as multimedia files and binary executables. We\u2019ll discuss how to design a blob store to manage vast amounts of diverse data efficiently.</p>\n<h3>Distributed Search</h3>\n<p>A distributed search system processes user queries and returns relevant content quickly. We\u2019ll delve into the components of a search system, including crawling, indexing, and searching, to understand how they work together.</p>\n<h3>Distributed Logging</h3>\n<p>Logging in distributed systems is I/O intensive and time-consuming. We\u2019ll design a scalable and reliable logging system to ensure efficient event tracking across multiple services.</p>\n<h3>Distributed Task Scheduling</h3>\n<p>A distributed task scheduler allocates resources to tasks intelligently, meeting task-level and system-level goals. This component is crucial for managing background processing and ensuring smooth operation.</p>\n<h3>Sharded Counters</h3>\n<p>Sharded counters handle millions of concurrent read/write requests, such as likes on a celebrity\u2019s tweet. We\u2019ll explore how to design an efficient distributed counting system that scales with user\u00a0demand.</p>\n<h3>Conventions for Building\u00a0Blocks</h3>\n<p>For each building block, we\u2019ll use a \u201cRequirements\u201d section to highlight the expected deliverables. This section will\u00a0include:</p>\n<ul>\n<li>\n<strong>Functional Requirements</strong>: Features a user of the designed system will be able to use, such as searching for content using a search\u00a0bar.</li>\n<li>\n<strong>Non-Functional Requirements (NFRs)</strong>: Criteria based on which users will consider the system usable, such as high availability, low latency, and scalability.</li>\n</ul>\n<h3>Final Thoughts</h3>\n<p>By understanding these building blocks and how they fit together, we can tackle any system design problem with confidence. Join me as we continue to explore the fascinating world of system design, building robust and scalable systems from the ground\u00a0up.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=836b7211b8a1\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Mastering System Design: Day 3\u200a\u2014\u200aBuilding Blocks for Modern System\u00a0Design</h3>\n<p>Welcome back to Day 3 of our system design journey! Today, we explore the building blocks of modern system design, much like using Lego pieces to create intricate and powerful structures. Let\u2019s dive into how these fundamental components come together to form robust, scalable\u00a0systems.</p>\n<h3>Introduction to Building Blocks for Modern System\u00a0Design</h3>\n<h3>The Bottom-Up Approach to System\u00a0Design</h3>\n<p>System design problems often share similarities, though their specific details may vary. By identifying and standardizing these common components, we can streamline the design process. Think of these components as Lego bricks, which can be reused and rearranged to build various\u00a0systems.</p>\n<p>The purpose of separating building blocks is to discuss their design thoroughly once. This means that later we can use them anywhere without having to go over them in detail again. This modular approach allows for the construction of more effective, capable\u00a0systems.</p>\n<p>Many of these building blocks are available for use in public clouds like Amazon Web Services (AWS), Azure, and Google Cloud Platform (GCP). While we won\u2019t build these systems in this course, you can use these constructs to cement your understanding.</p>\n<h3>Using Building Blocks to Devise a Bottom-Up Approach</h3>\n<p>By understanding and utilizing these building blocks, we can tackle system design problems from the ground up, ensuring a solid foundation. Here are the key building blocks we\u2019ll cover in\u00a0detail:</p>\n<h3>Domain Name System\u00a0(DNS)</h3>\n<p>This building block focuses on designing hierarchical and distributed naming systems for computers connected to the Internet via different protocols. DNS translates human-readable domain names into IP addresses, facilitating communication between\u00a0devices.</p>\n<h3>Load Balancers</h3>\n<p>Load balancers distribute incoming client requests among a pool of available servers, ensuring no single server is overwhelmed. This component enhances system reliability and availability by managing traffic and bypassing failed\u00a0servers.</p>\n<h3>Databases</h3>\n<p>Databases store, retrieve, modify, and delete data in connection with various data-processing procedures. We\u2019ll discuss different database types, replication, partitioning, and the analysis of distributed databases to understand how they handle large-scale data.</p>\n<h3>Key-Value Store</h3>\n<p>A key-value store is a non-relational database that stores data in key-value pairs. This building block is essential for achieving scalability, durability, and configurability in systems that require quick access to\u00a0data.</p>\n<h3>Content Delivery Network\u00a0(CDN)</h3>\n<p>CDNs keep viral content such as videos, images, audio, and web pages close to end users, reducing latency and the burden on data centers. We\u2019ll explore how CDNs efficiently deliver content to users around the\u00a0world.</p>\n<h3>Sequencer</h3>\n<p>Sequencers generate unique IDs, maintaining causality in distributed systems. We\u2019ll examine three different methods for generating unique IDs, ensuring consistency and order in data processing.</p>\n<h3>Service Monitoring</h3>\n<p>Monitoring systems analyze the system and alert stakeholders if issues arise. We\u2019ll build two monitoring systems: one for server-side errors and another for client-side errors, providing early warning and proactive management of potential problems.</p>\n<h3>Distributed Caching</h3>\n<p>Distributed caching involves multiple cache servers coordinating to store frequently accessed data. This component enhances system performance by reducing the load on primary data\u00a0stores.</p>\n<h3>Distributed Messaging Queue</h3>\n<p>A distributed messaging queue decouples interacting entities (producers and consumers), allowing independent scalability and enhanced reliability. We\u2019ll explore how this component facilitates asynchronous communication between services.</p>\n<h3>Publish-Subscribe System (Pub-Sub)</h3>\n<p>Pub-Sub systems enable asynchronous service-to-service communication, popular in serverless, microservices architectures, and data processing systems. We\u2019ll design a robust pub-sub system to handle various messaging needs.</p>\n<h3>Rate Limiter</h3>\n<p>Rate limiters throttle incoming requests based on predefined limits, protecting services from excessive usage. This defensive layer ensures system stability and prevents\u00a0abuse.</p>\n<h3>Blob Store</h3>\n<p>Blob stores provide storage solutions for unstructured data, such as multimedia files and binary executables. We\u2019ll discuss how to design a blob store to manage vast amounts of diverse data efficiently.</p>\n<h3>Distributed Search</h3>\n<p>A distributed search system processes user queries and returns relevant content quickly. We\u2019ll delve into the components of a search system, including crawling, indexing, and searching, to understand how they work together.</p>\n<h3>Distributed Logging</h3>\n<p>Logging in distributed systems is I/O intensive and time-consuming. We\u2019ll design a scalable and reliable logging system to ensure efficient event tracking across multiple services.</p>\n<h3>Distributed Task Scheduling</h3>\n<p>A distributed task scheduler allocates resources to tasks intelligently, meeting task-level and system-level goals. This component is crucial for managing background processing and ensuring smooth operation.</p>\n<h3>Sharded Counters</h3>\n<p>Sharded counters handle millions of concurrent read/write requests, such as likes on a celebrity\u2019s tweet. We\u2019ll explore how to design an efficient distributed counting system that scales with user\u00a0demand.</p>\n<h3>Conventions for Building\u00a0Blocks</h3>\n<p>For each building block, we\u2019ll use a \u201cRequirements\u201d section to highlight the expected deliverables. This section will\u00a0include:</p>\n<ul>\n<li>\n<strong>Functional Requirements</strong>: Features a user of the designed system will be able to use, such as searching for content using a search\u00a0bar.</li>\n<li>\n<strong>Non-Functional Requirements (NFRs)</strong>: Criteria based on which users will consider the system usable, such as high availability, low latency, and scalability.</li>\n</ul>\n<h3>Final Thoughts</h3>\n<p>By understanding these building blocks and how they fit together, we can tackle any system design problem with confidence. Join me as we continue to explore the fascinating world of system design, building robust and scalable systems from the ground\u00a0up.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=836b7211b8a1\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]},{"title":"Mastering System Design: Day 2\u200a\u2014\u200aQuick Calculations for Complex Systems","pubDate":"2024-07-22 20:39:45","link":"https://medium.com/@snehagiranje05/mastering-system-design-day-2-quick-calculations-for-complex-systems-f6099315d706?source=rss-fcc1a302fb6e------2","guid":"https://medium.com/p/f6099315d706","author":"Snehagiranje","thumbnail":"","description":"\n<h3>Mastering System Design: Day 2\u200a\u2014\u200aQuick Calculations for Complex\u00a0Systems</h3>\n<p>Welcome back to my system design journey! On Day 2, we explored the practical world of back-of-the-envelope calculations (BOTECs) and their significance in system design. Here\u2019s a detailed look at the insights and key takeaways from today\u2019s\u00a0session.</p>\n<h3>Putting Back-of-the-Envelope Numbers in Perspective</h3>\n<p>Back-of-the-envelope calculations (BOTECs) involve swift, approximate, and simplified estimations. These quick calculations serve as preliminary evaluations of crucial parameters and system feasibility. For instance, estimating the population of a neighborhood by counting houses in a sample area and extrapolating the data is a typical\u00a0BOTEC.</p>\n<h4>Common BOTEC Estimations</h4>\n<ul>\n<li>\n<strong>Concurrent TCP Connections</strong>: Estimating how many TCP connections a server can\u00a0support.</li>\n<li>\n<strong>Requests Per Second (RPS)</strong>: Determining how many requests a web, database, or cache server can\u00a0handle.</li>\n<li>\n<strong>Storage Requirements</strong>: Calculating the storage needs of a\u00a0service.</li>\n</ul>\n<h3>Types of Data Center\u00a0Servers</h3>\n<p>Data centers employ various servers to handle different workloads efficiently. Here are some common\u00a0types:</p>\n<h4>Web Servers</h4>\n<p>Web servers handle API calls and typically require good processing resources. For example, Facebook has used web servers with 32 GB of RAM and 500 GB of\u00a0storage.</p>\n<h4>Application Servers</h4>\n<p>These servers require extensive computational and storage resources. Facebook has used application servers with up to 256 GB of RAM and 6.5 TB of\u00a0storage.</p>\n<h4>Storage Servers</h4>\n<p>With the explosive growth of internet users, storage servers have multiplied. For instance, Facebook uses servers with up to 120 TB of storage capacity and 32 GB of\u00a0RAM.</p>\n<h3>Standard Numbers to\u00a0Remember</h3>\n<p>Understanding standard latencies and throughput numbers is crucial for resource estimation. Here are some important numbers to keep in\u00a0mind:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1012/1*RKaakSNPNErXd1GEARbAiQ.png\"></figure><h4>Throughput Rates</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1012/1*hIE6WNAOrxoWyDPiIeWPHg.png\"></figure><h3>Introduction to Resource Estimation</h3>\n<p>Now that we\u2019ve established a foundation for resource estimation, let\u2019s apply our newfound knowledge to estimate resources like servers, storage, and bandwidth. We\u2019ll use a Twitter-like service as our case study, make some assumptions, and base our estimations on those assumptions. Let\u2019s dive\u00a0in!</p>\n<h4>Number of Servers\u00a0Required</h4>\n<p>To estimate the number of servers required, let\u2019s make the following assumptions for a Twitter-like service:</p>\n<p><strong>Assumptions:</strong></p>\n<ul>\n<li>There are 500 million (M) daily active users\u00a0(DAUs).</li>\n<li>Each user makes 20 requests per day on\u00a0average.</li>\n<li>A single server with 64 cores can handle 64,000 requests per second\u00a0(RPS).</li>\n</ul>\n<p><strong>Estimating the Number of\u00a0Servers</strong></p>\n<p>Using these assumptions, we can calculate the number of servers\u00a0needed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*TnKrGBlvOmSgOLgIrkZv1Q.png\"></figure><p>This initial estimate suggests that 157,000 servers would be required to handle the peak load if all requests arrived simultaneously. However, this number seems impractically high, so we need to consider ways to optimize.</p>\n<h4>Different Scenarios for Server Requirements</h4>\n<p><strong>1. Base Scenario (All Requests at Peak\u00a0Load)</strong></p>\n<ul><li>\n<strong>Total servers needed</strong>:\u00a0157,000</li></ul>\n<p><strong>2. Optimized Scenario (Using the Pareto Principle)</strong> The Pareto principle (80/20 rule) suggests that 80% of peak traffic occurs within 20% of the time (a 4.8-hour window in 24\u00a0hours).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*WatbuoPQYUagCi32eT-UHQ.png\"></figure><p><strong>3. Low Bound Scenario (Even Distribution Throughout the Day)</strong> In this scenario, we assume that the requests are evenly distributed throughout the\u00a0day:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3zIwbCpmh0FM7kJ0UG9tvw.png\"></figure><p>These scenarios illustrate the wide range of potential server requirements based on different assumptions about request distribution.</p>\n<p><strong>Points to\u00a0Ponder</strong></p>\n<ul>\n<li>\n<strong>Hidden Assumptions:</strong> Our calculations assume all requests are evenly distributed throughout the day, which is unlikely in real-world scenarios. We also assume that each server can handle its maximum RPS without degradation.</li>\n<li>\n<strong>Plausibility Test:</strong> If our estimate suggests only a few servers for a large service with millions of DAUs, it\u2019s a lower bound but likely unrealistic.</li>\n</ul>\n<h4>Peak Capacity and Load Optimization</h4>\n<p>Large services need to be prepared for sudden spikes in traffic, often referred to as flash crowds. To estimate peak capacity, we assume all requests occur within a specific second of the day. This helps us gauge the system\u2019s maximum\u00a0load.</p>\n<p><strong>Improving RPS</strong></p>\n<p>To further optimize, we can enhance the RPS that each server can handle. For example, WhatsApp managed 2 million concurrent TCP connections on one server through extensive engineering. Similarly, a research system optimized for I/O improved RPS three times more than its competitors.</p>\n<p><strong>Cost of\u00a0Servers</strong></p>\n<p>To get a handle on server costs, we consider an EC2 instance type (m7i.16xlarge) with a 64-core processor and 256 GB of RAM. The hourly cost for such an instance is $3.54816 with a 1-year contract\u00a0plan.</p>\n<p><strong>Cost Analysis:</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4iLehDwKM97XgAqSk8ZAWg.png\"></figure><p>This cost analysis highlights the importance of optimizing server usage and considering budget constraints in system\u00a0design.</p>\n<h4>Storage and Bandwidth Requirements</h4>\n<p><strong>Storage Requirements</strong></p>\n<p>Using the following assumptions, we estimate Twitter\u2019s storage\u00a0needs:</p>\n<ul>\n<li>500M DAUs</li>\n<li>Each user posts three tweets\u00a0daily</li>\n<li>10% of tweets contain images (200 KB\u00a0each)</li>\n<li>5% contain videos (3 MB\u00a0each)</li>\n<li>Text and metadata require 250 bytes per\u00a0tweet</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uULmEZWBwHYbIUt6tF_m4g.png\"></figure><p><strong>Bandwidth Requirements</strong></p>\n<p>Estimating bandwidth involves calculating incoming and outgoing\u00a0data:</p>\n<ul>\n<li>\n<strong>Incoming traffic</strong>: 255 TB/day \u224824 Gbps\\approx 24 \\text{ Gbps}\u224824\u00a0Gbps</li>\n<li>\n<strong>Outgoing traffic</strong>: Assuming 50 tweets viewed per user/day, with a mix of text, images, and\u00a0videos.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*l_-4I0BGwr7WmyDuhZzvuQ.png\"></figure><p>These estimates depend on the specific traffic mix and read/write ratios.</p>\n<h3>Final Thoughts</h3>\n<p>This lesson serves as a template for resource estimations throughout the course. BOTECs help demonstrate a system\u2019s feasibility under a specific design, showcasing a candidate\u2019s problem-solving skills during interviews. In real-world scenarios, organizations rely on precise measurements tailored to their specific workloads for accurate estimations.</p>\n<p>Join me as we continue exploring the fascinating world of system design. Stay tuned for more insights and key takeaways in the upcoming\u00a0blogs!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f6099315d706\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Mastering System Design: Day 2\u200a\u2014\u200aQuick Calculations for Complex\u00a0Systems</h3>\n<p>Welcome back to my system design journey! On Day 2, we explored the practical world of back-of-the-envelope calculations (BOTECs) and their significance in system design. Here\u2019s a detailed look at the insights and key takeaways from today\u2019s\u00a0session.</p>\n<h3>Putting Back-of-the-Envelope Numbers in Perspective</h3>\n<p>Back-of-the-envelope calculations (BOTECs) involve swift, approximate, and simplified estimations. These quick calculations serve as preliminary evaluations of crucial parameters and system feasibility. For instance, estimating the population of a neighborhood by counting houses in a sample area and extrapolating the data is a typical\u00a0BOTEC.</p>\n<h4>Common BOTEC Estimations</h4>\n<ul>\n<li>\n<strong>Concurrent TCP Connections</strong>: Estimating how many TCP connections a server can\u00a0support.</li>\n<li>\n<strong>Requests Per Second (RPS)</strong>: Determining how many requests a web, database, or cache server can\u00a0handle.</li>\n<li>\n<strong>Storage Requirements</strong>: Calculating the storage needs of a\u00a0service.</li>\n</ul>\n<h3>Types of Data Center\u00a0Servers</h3>\n<p>Data centers employ various servers to handle different workloads efficiently. Here are some common\u00a0types:</p>\n<h4>Web Servers</h4>\n<p>Web servers handle API calls and typically require good processing resources. For example, Facebook has used web servers with 32 GB of RAM and 500 GB of\u00a0storage.</p>\n<h4>Application Servers</h4>\n<p>These servers require extensive computational and storage resources. Facebook has used application servers with up to 256 GB of RAM and 6.5 TB of\u00a0storage.</p>\n<h4>Storage Servers</h4>\n<p>With the explosive growth of internet users, storage servers have multiplied. For instance, Facebook uses servers with up to 120 TB of storage capacity and 32 GB of\u00a0RAM.</p>\n<h3>Standard Numbers to\u00a0Remember</h3>\n<p>Understanding standard latencies and throughput numbers is crucial for resource estimation. Here are some important numbers to keep in\u00a0mind:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1012/1*RKaakSNPNErXd1GEARbAiQ.png\"></figure><h4>Throughput Rates</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1012/1*hIE6WNAOrxoWyDPiIeWPHg.png\"></figure><h3>Introduction to Resource Estimation</h3>\n<p>Now that we\u2019ve established a foundation for resource estimation, let\u2019s apply our newfound knowledge to estimate resources like servers, storage, and bandwidth. We\u2019ll use a Twitter-like service as our case study, make some assumptions, and base our estimations on those assumptions. Let\u2019s dive\u00a0in!</p>\n<h4>Number of Servers\u00a0Required</h4>\n<p>To estimate the number of servers required, let\u2019s make the following assumptions for a Twitter-like service:</p>\n<p><strong>Assumptions:</strong></p>\n<ul>\n<li>There are 500 million (M) daily active users\u00a0(DAUs).</li>\n<li>Each user makes 20 requests per day on\u00a0average.</li>\n<li>A single server with 64 cores can handle 64,000 requests per second\u00a0(RPS).</li>\n</ul>\n<p><strong>Estimating the Number of\u00a0Servers</strong></p>\n<p>Using these assumptions, we can calculate the number of servers\u00a0needed:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*TnKrGBlvOmSgOLgIrkZv1Q.png\"></figure><p>This initial estimate suggests that 157,000 servers would be required to handle the peak load if all requests arrived simultaneously. However, this number seems impractically high, so we need to consider ways to optimize.</p>\n<h4>Different Scenarios for Server Requirements</h4>\n<p><strong>1. Base Scenario (All Requests at Peak\u00a0Load)</strong></p>\n<ul><li>\n<strong>Total servers needed</strong>:\u00a0157,000</li></ul>\n<p><strong>2. Optimized Scenario (Using the Pareto Principle)</strong> The Pareto principle (80/20 rule) suggests that 80% of peak traffic occurs within 20% of the time (a 4.8-hour window in 24\u00a0hours).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*WatbuoPQYUagCi32eT-UHQ.png\"></figure><p><strong>3. Low Bound Scenario (Even Distribution Throughout the Day)</strong> In this scenario, we assume that the requests are evenly distributed throughout the\u00a0day:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3zIwbCpmh0FM7kJ0UG9tvw.png\"></figure><p>These scenarios illustrate the wide range of potential server requirements based on different assumptions about request distribution.</p>\n<p><strong>Points to\u00a0Ponder</strong></p>\n<ul>\n<li>\n<strong>Hidden Assumptions:</strong> Our calculations assume all requests are evenly distributed throughout the day, which is unlikely in real-world scenarios. We also assume that each server can handle its maximum RPS without degradation.</li>\n<li>\n<strong>Plausibility Test:</strong> If our estimate suggests only a few servers for a large service with millions of DAUs, it\u2019s a lower bound but likely unrealistic.</li>\n</ul>\n<h4>Peak Capacity and Load Optimization</h4>\n<p>Large services need to be prepared for sudden spikes in traffic, often referred to as flash crowds. To estimate peak capacity, we assume all requests occur within a specific second of the day. This helps us gauge the system\u2019s maximum\u00a0load.</p>\n<p><strong>Improving RPS</strong></p>\n<p>To further optimize, we can enhance the RPS that each server can handle. For example, WhatsApp managed 2 million concurrent TCP connections on one server through extensive engineering. Similarly, a research system optimized for I/O improved RPS three times more than its competitors.</p>\n<p><strong>Cost of\u00a0Servers</strong></p>\n<p>To get a handle on server costs, we consider an EC2 instance type (m7i.16xlarge) with a 64-core processor and 256 GB of RAM. The hourly cost for such an instance is $3.54816 with a 1-year contract\u00a0plan.</p>\n<p><strong>Cost Analysis:</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4iLehDwKM97XgAqSk8ZAWg.png\"></figure><p>This cost analysis highlights the importance of optimizing server usage and considering budget constraints in system\u00a0design.</p>\n<h4>Storage and Bandwidth Requirements</h4>\n<p><strong>Storage Requirements</strong></p>\n<p>Using the following assumptions, we estimate Twitter\u2019s storage\u00a0needs:</p>\n<ul>\n<li>500M DAUs</li>\n<li>Each user posts three tweets\u00a0daily</li>\n<li>10% of tweets contain images (200 KB\u00a0each)</li>\n<li>5% contain videos (3 MB\u00a0each)</li>\n<li>Text and metadata require 250 bytes per\u00a0tweet</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uULmEZWBwHYbIUt6tF_m4g.png\"></figure><p><strong>Bandwidth Requirements</strong></p>\n<p>Estimating bandwidth involves calculating incoming and outgoing\u00a0data:</p>\n<ul>\n<li>\n<strong>Incoming traffic</strong>: 255 TB/day \u224824 Gbps\\approx 24 \\text{ Gbps}\u224824\u00a0Gbps</li>\n<li>\n<strong>Outgoing traffic</strong>: Assuming 50 tweets viewed per user/day, with a mix of text, images, and\u00a0videos.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*l_-4I0BGwr7WmyDuhZzvuQ.png\"></figure><p>These estimates depend on the specific traffic mix and read/write ratios.</p>\n<h3>Final Thoughts</h3>\n<p>This lesson serves as a template for resource estimations throughout the course. BOTECs help demonstrate a system\u2019s feasibility under a specific design, showcasing a candidate\u2019s problem-solving skills during interviews. In real-world scenarios, organizations rely on precise measurements tailored to their specific workloads for accurate estimations.</p>\n<p>Join me as we continue exploring the fascinating world of system design. Stay tuned for more insights and key takeaways in the upcoming\u00a0blogs!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f6099315d706\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]},{"title":"Day 1: System Design Fundamentals\u200a\u2014\u200aA Comprehensive Overview","pubDate":"2024-07-18 22:07:34","link":"https://medium.com/@snehagiranje05/day-1-system-design-fundamentals-a-comprehensive-overview-8d246a857530?source=rss-fcc1a302fb6e------2","guid":"https://medium.com/p/8d246a857530","author":"Snehagiranje","thumbnail":"","description":"\n<h3>Mastering System Design: Day 1 Insights and Key Takeaways</h3>\n<p>Welcome to my journey into the world of system design! Today marks the beginning of an exciting adventure as I delve into the intricacies of building and scaling distributed systems. Here are my insights and key takeaways from Day 1 of the System Design\u00a0course.</p>\n<h3>Taming Complexity: An Introduction to Modern System\u00a0Design</h3>\n<p>Imagine you\u2019re tasked with designing a city. You need to ensure that the infrastructure can handle a growing population, provide reliable services, and adapt to future needs. System design is akin to city planning but for software systems. It\u2019s about creating distributed systems that scale effortlessly and perform efficiently, all while managing the inherent complexity.</p>\n<h3>Why System\u00a0Design?</h3>\n<p>Distributed systems naturally excel at scaling but come with their own set of challenges. System design helps us navigate these complexities, ensuring our systems are robust, reliable, and maintainable. It\u2019s a crucial skill for any software engineer aiming to make an impact in today\u2019s tech landscape.</p>\n<h3>Cracking the Code: System Design Interviews</h3>\n<h3>What\u2019s a System Design Interview?</h3>\n<p>Think of it as a high-stakes brainstorming session. Instead of writing code, you\u2019ll map out a system\u2019s architecture, making strategic decisions on components and their interactions. It\u2019s less about the final answer and more about the journey you take to get\u00a0there.</p>\n<h3>Preparation Tips</h3>\n<ol>\n<li>\n<strong>Dive into Technical Blogs</strong>: Companies like Google, Amazon, and Uber regularly share their technical insights. These blogs are treasure troves of real-world challenges and solutions.</li>\n<li>\n<strong>Ask Why</strong>: When exploring how systems like Instagram or Twitter work, dig deeper. Why did they choose a specific database? What trade-offs did they consider?</li>\n<li>\n<strong>Build Side Projects</strong>: Nothing beats hands-on experience. Start simple and iterate. Build a project from scratch and refine it as you\u00a0learn.</li>\n<li>\n<strong>Mock Interviews</strong>: Practice mock interviews to simulate real interview conditions and receive feedback.</li>\n</ol>\n<h3>Performing Well in Interviews</h3>\n<ol>\n<li>\n<strong>Ask Refining Questions</strong>: Clarify the problem by asking detailed questions. It shows you\u2019re thinking critically.</li>\n<li>\n<strong>Handle Data Smartly</strong>: Understand data characteristics\u200a\u2014\u200asize, growth rate, read/write patterns. Choose the right storage and processing systems.</li>\n<li>\n<strong>Discuss Components</strong>: Identify necessary components like databases, caches, and load balancers. Explain their roles and interactions.</li>\n<li>\n<strong>Highlight Trade-offs</strong>: Every design has pros and cons. Discuss these openly, and justify your choices. Acknowledge weaknesses and outline how you\u2019ll address\u00a0them.</li>\n</ol>\n<h3>The Power of Abstractions</h3>\n<h3>What is Abstraction?</h3>\n<p>Abstraction is like zooming out on a complex map to see the bigger picture. It simplifies the intricate details, allowing us to focus on broader goals. In system design, we use abstractions to manage complexity effectively.</p>\n<h3>Network Abstractions: Remote Procedure Calls\u00a0(RPC)</h3>\n<p>RPCs are the magic behind interprocess communication in distributed systems. They make remote procedures appear local, simplifying the development process.</p>\n<h3>Consistency Models</h3>\n<p>Consistency models define how data updates are handled in distributed systems. They range from eventual consistency, where updates propagate over time, to strict consistency (linearizability), ensuring immediate visibility of\u00a0updates.</p>\n<h3>Failure Models</h3>\n<p>Understanding failure models is crucial for designing resilient systems. They\u00a0include:</p>\n<ul>\n<li>\n<strong>Fail-stop</strong>: A node halts permanently but is detectable by other\u00a0nodes.</li>\n<li>\n<strong>Crash</strong>: A node stops silently and undetectably.</li>\n<li>\n<strong>Omission</strong>: Failures in sending or receiving messages.</li>\n<li>\n<strong>Temporal</strong>: Correct results produced too\u00a0late.</li>\n<li>\n<strong>Byzantine</strong>: Nodes exhibit arbitrary behavior, often due to malicious attacks.</li>\n</ul>\n<h3>Non-functional System Characteristics: The Pillars of System\u00a0Design</h3>\n<h3>Availability</h3>\n<p>Availability is the percentage of time a service is operational and accessible. Measured in \u201cnines\u201d (e.g., 99.9%), it indicates the allowable downtime over a\u00a0period.</p>\n<h3>Reliability</h3>\n<p>Reliability measures a system\u2019s ability to function correctly over time. It\u2019s about minimizing failure frequency and\u00a0impact.</p>\n<h3>Scalability</h3>\n<p>Scalability is the ability to handle increased workload by adding resources. It can\u00a0be:</p>\n<ul>\n<li>\n<strong>Vertical Scaling (Scaling Up)</strong>: Adding resources to an existing\u00a0machine.</li>\n<li>\n<strong>Horizontal Scaling (Scaling Out)</strong>: Adding more machines to the\u00a0system.</li>\n</ul>\n<h3>Maintainability</h3>\n<p>Maintainability is about how easily a system can be modified and repaired. It\u2019s quantified by Mean Time To Repair (MTTR), the average time to restore a failed component.</p>\n<h3>Fault Tolerance</h3>\n<p>Fault tolerance ensures a system continues operating despite failures. Techniques include:</p>\n<ul>\n<li>\n<strong>Replication</strong>: Creating multiple data\u00a0copies.</li>\n<li>\n<strong>Checkpointing</strong>: Saving system states at intervals for recovery.</li>\n</ul>\n<h3>Final Thoughts</h3>\n<p>Join me on this journey as we dive deeper into the fascinating world of system design. Stay tuned for more insights and key takeaways from upcoming sessions!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8d246a857530\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Mastering System Design: Day 1 Insights and Key Takeaways</h3>\n<p>Welcome to my journey into the world of system design! Today marks the beginning of an exciting adventure as I delve into the intricacies of building and scaling distributed systems. Here are my insights and key takeaways from Day 1 of the System Design\u00a0course.</p>\n<h3>Taming Complexity: An Introduction to Modern System\u00a0Design</h3>\n<p>Imagine you\u2019re tasked with designing a city. You need to ensure that the infrastructure can handle a growing population, provide reliable services, and adapt to future needs. System design is akin to city planning but for software systems. It\u2019s about creating distributed systems that scale effortlessly and perform efficiently, all while managing the inherent complexity.</p>\n<h3>Why System\u00a0Design?</h3>\n<p>Distributed systems naturally excel at scaling but come with their own set of challenges. System design helps us navigate these complexities, ensuring our systems are robust, reliable, and maintainable. It\u2019s a crucial skill for any software engineer aiming to make an impact in today\u2019s tech landscape.</p>\n<h3>Cracking the Code: System Design Interviews</h3>\n<h3>What\u2019s a System Design Interview?</h3>\n<p>Think of it as a high-stakes brainstorming session. Instead of writing code, you\u2019ll map out a system\u2019s architecture, making strategic decisions on components and their interactions. It\u2019s less about the final answer and more about the journey you take to get\u00a0there.</p>\n<h3>Preparation Tips</h3>\n<ol>\n<li>\n<strong>Dive into Technical Blogs</strong>: Companies like Google, Amazon, and Uber regularly share their technical insights. These blogs are treasure troves of real-world challenges and solutions.</li>\n<li>\n<strong>Ask Why</strong>: When exploring how systems like Instagram or Twitter work, dig deeper. Why did they choose a specific database? What trade-offs did they consider?</li>\n<li>\n<strong>Build Side Projects</strong>: Nothing beats hands-on experience. Start simple and iterate. Build a project from scratch and refine it as you\u00a0learn.</li>\n<li>\n<strong>Mock Interviews</strong>: Practice mock interviews to simulate real interview conditions and receive feedback.</li>\n</ol>\n<h3>Performing Well in Interviews</h3>\n<ol>\n<li>\n<strong>Ask Refining Questions</strong>: Clarify the problem by asking detailed questions. It shows you\u2019re thinking critically.</li>\n<li>\n<strong>Handle Data Smartly</strong>: Understand data characteristics\u200a\u2014\u200asize, growth rate, read/write patterns. Choose the right storage and processing systems.</li>\n<li>\n<strong>Discuss Components</strong>: Identify necessary components like databases, caches, and load balancers. Explain their roles and interactions.</li>\n<li>\n<strong>Highlight Trade-offs</strong>: Every design has pros and cons. Discuss these openly, and justify your choices. Acknowledge weaknesses and outline how you\u2019ll address\u00a0them.</li>\n</ol>\n<h3>The Power of Abstractions</h3>\n<h3>What is Abstraction?</h3>\n<p>Abstraction is like zooming out on a complex map to see the bigger picture. It simplifies the intricate details, allowing us to focus on broader goals. In system design, we use abstractions to manage complexity effectively.</p>\n<h3>Network Abstractions: Remote Procedure Calls\u00a0(RPC)</h3>\n<p>RPCs are the magic behind interprocess communication in distributed systems. They make remote procedures appear local, simplifying the development process.</p>\n<h3>Consistency Models</h3>\n<p>Consistency models define how data updates are handled in distributed systems. They range from eventual consistency, where updates propagate over time, to strict consistency (linearizability), ensuring immediate visibility of\u00a0updates.</p>\n<h3>Failure Models</h3>\n<p>Understanding failure models is crucial for designing resilient systems. They\u00a0include:</p>\n<ul>\n<li>\n<strong>Fail-stop</strong>: A node halts permanently but is detectable by other\u00a0nodes.</li>\n<li>\n<strong>Crash</strong>: A node stops silently and undetectably.</li>\n<li>\n<strong>Omission</strong>: Failures in sending or receiving messages.</li>\n<li>\n<strong>Temporal</strong>: Correct results produced too\u00a0late.</li>\n<li>\n<strong>Byzantine</strong>: Nodes exhibit arbitrary behavior, often due to malicious attacks.</li>\n</ul>\n<h3>Non-functional System Characteristics: The Pillars of System\u00a0Design</h3>\n<h3>Availability</h3>\n<p>Availability is the percentage of time a service is operational and accessible. Measured in \u201cnines\u201d (e.g., 99.9%), it indicates the allowable downtime over a\u00a0period.</p>\n<h3>Reliability</h3>\n<p>Reliability measures a system\u2019s ability to function correctly over time. It\u2019s about minimizing failure frequency and\u00a0impact.</p>\n<h3>Scalability</h3>\n<p>Scalability is the ability to handle increased workload by adding resources. It can\u00a0be:</p>\n<ul>\n<li>\n<strong>Vertical Scaling (Scaling Up)</strong>: Adding resources to an existing\u00a0machine.</li>\n<li>\n<strong>Horizontal Scaling (Scaling Out)</strong>: Adding more machines to the\u00a0system.</li>\n</ul>\n<h3>Maintainability</h3>\n<p>Maintainability is about how easily a system can be modified and repaired. It\u2019s quantified by Mean Time To Repair (MTTR), the average time to restore a failed component.</p>\n<h3>Fault Tolerance</h3>\n<p>Fault tolerance ensures a system continues operating despite failures. Techniques include:</p>\n<ul>\n<li>\n<strong>Replication</strong>: Creating multiple data\u00a0copies.</li>\n<li>\n<strong>Checkpointing</strong>: Saving system states at intervals for recovery.</li>\n</ul>\n<h3>Final Thoughts</h3>\n<p>Join me on this journey as we dive deeper into the fascinating world of system design. Stay tuned for more insights and key takeaways from upcoming sessions!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8d246a857530\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]},{"title":"Unveiling the Magic: Understanding Mock and MagicMock in Python","pubDate":"2024-06-18 14:01:28","link":"https://medium.com/@snehagiranje05/unveiling-the-magic-understanding-mock-and-magicmock-in-python-ecadf1f1013c?source=rss-fcc1a302fb6e------2","guid":"https://medium.com/p/ecadf1f1013c","author":"Snehagiranje","thumbnail":"","description":"\n<p>In the realm of Python testing, the unittest.mock module is a powerful ally. Among its tools, Mock and MagicMock stand out, often sparking curiosity about their differences and appropriate use cases. In this post, we'll dive into what Mock and MagicMock are, how they differ, and when to use each with practical examples.</p>\n<h3>What is\u00a0Mock?</h3>\n<p>Mock is a flexible and versatile tool from the unittest.mock module that allows you to replace parts of your system under test and make assertions about how they were used. Essentially, it helps you simulate and test interactions with other parts of your code in isolation.</p>\n<p><strong>Basic Example of\u00a0Mock:</strong></p>\n<pre>from unittest.mock import Mock<br><br># Creating a Mock object<br>mock = Mock()<br><br># Setting a return value for a method<br>mock.some_method.return_value = 'Hello, World!'<br><br># Calling the method<br>result = mock.some_method()<br><br># Asserting the method was called<br>assert mock.some_method.called<br>assert result == 'Hello, World!'</pre>\n<p>In this example, we create a mock object and specify that calling some_method should return \"Hello, World!\". We can then assert that some_method was indeed called and that it returned the expected\u00a0value.</p>\n<h3>What is MagicMock?</h3>\n<p>MagicMock is a subclass of Mock that includes default implementations of most of the \"magic methods\" (or \"dunder methods\"), which are the special methods with double underscores (e.g., __len__, __getitem__, etc.). This makes MagicMock particularly useful when you need to mock objects that rely heavily on these special\u00a0methods.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/816/1*N0HKUPKfin_rpoItZXESYA.jpeg\"></figure><p><strong>Basic Example of MagicMock:</strong></p>\n<pre>from unittest.mock import MagicMock<br><br># Creating a MagicMock object<br>magic_mock = MagicMock()<br><br># Setting a return value for a magic method<br>magic_mock.__str__.return_value = 'MagicMocked!'<br><br># Calling the magic method<br>result = str(magic_mock)<br><br># Asserting the magic method was called<br>assert magic_mock.__str__.called<br>assert result == 'MagicMocked!'</pre>\n<p>Here, we create a MagicMock object and mock its __str__ method to return \"MagicMocked!\". This showcases how MagicMock can handle special methods seamlessly.</p>\n<h3>Key Differences Between Mock and MagicMock</h3>\n<p><strong>Magic Methods:</strong></p>\n<ul>\n<li>\n<strong>Mock:</strong> Does not include implementations for magic methods by default. You have to define them explicitly.</li>\n<li>\n<strong>MagicMock:</strong> Includes default implementations for most magic methods, making it easier to mock objects that use these\u00a0methods.</li>\n</ul>\n<p><strong>Use Case:</strong></p>\n<ul>\n<li>\n<strong>Mock:</strong> Use when you need to mock regular methods and attributes.</li>\n<li>\n<strong>MagicMock:</strong> Use when you need to mock an object that relies heavily on magic\u00a0methods.</li>\n</ul>\n<h3>When to Use Mock vs. MagicMock</h3>\n<p><strong>Use </strong><strong>Mock\u00a0when:</strong></p>\n<ul>\n<li>You are testing interactions with standard methods and attributes.</li>\n<li>You want more control over what is mocked and avoid unintended behavior from automatically mocked magic\u00a0methods.</li>\n</ul>\n<p><strong>Use </strong><strong>MagicMock when:</strong></p>\n<ul>\n<li>You need to mock an object that uses magic methods extensively (e.g., objects implementing custom behavior for operations like __add__, __getitem__, etc.).</li>\n<li>You prefer convenience and reduced boilerplate for setting up such\u00a0mocks.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ecadf1f1013c\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>In the realm of Python testing, the unittest.mock module is a powerful ally. Among its tools, Mock and MagicMock stand out, often sparking curiosity about their differences and appropriate use cases. In this post, we'll dive into what Mock and MagicMock are, how they differ, and when to use each with practical examples.</p>\n<h3>What is\u00a0Mock?</h3>\n<p>Mock is a flexible and versatile tool from the unittest.mock module that allows you to replace parts of your system under test and make assertions about how they were used. Essentially, it helps you simulate and test interactions with other parts of your code in isolation.</p>\n<p><strong>Basic Example of\u00a0Mock:</strong></p>\n<pre>from unittest.mock import Mock<br><br># Creating a Mock object<br>mock = Mock()<br><br># Setting a return value for a method<br>mock.some_method.return_value = 'Hello, World!'<br><br># Calling the method<br>result = mock.some_method()<br><br># Asserting the method was called<br>assert mock.some_method.called<br>assert result == 'Hello, World!'</pre>\n<p>In this example, we create a mock object and specify that calling some_method should return \"Hello, World!\". We can then assert that some_method was indeed called and that it returned the expected\u00a0value.</p>\n<h3>What is MagicMock?</h3>\n<p>MagicMock is a subclass of Mock that includes default implementations of most of the \"magic methods\" (or \"dunder methods\"), which are the special methods with double underscores (e.g., __len__, __getitem__, etc.). This makes MagicMock particularly useful when you need to mock objects that rely heavily on these special\u00a0methods.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/816/1*N0HKUPKfin_rpoItZXESYA.jpeg\"></figure><p><strong>Basic Example of MagicMock:</strong></p>\n<pre>from unittest.mock import MagicMock<br><br># Creating a MagicMock object<br>magic_mock = MagicMock()<br><br># Setting a return value for a magic method<br>magic_mock.__str__.return_value = 'MagicMocked!'<br><br># Calling the magic method<br>result = str(magic_mock)<br><br># Asserting the magic method was called<br>assert magic_mock.__str__.called<br>assert result == 'MagicMocked!'</pre>\n<p>Here, we create a MagicMock object and mock its __str__ method to return \"MagicMocked!\". This showcases how MagicMock can handle special methods seamlessly.</p>\n<h3>Key Differences Between Mock and MagicMock</h3>\n<p><strong>Magic Methods:</strong></p>\n<ul>\n<li>\n<strong>Mock:</strong> Does not include implementations for magic methods by default. You have to define them explicitly.</li>\n<li>\n<strong>MagicMock:</strong> Includes default implementations for most magic methods, making it easier to mock objects that use these\u00a0methods.</li>\n</ul>\n<p><strong>Use Case:</strong></p>\n<ul>\n<li>\n<strong>Mock:</strong> Use when you need to mock regular methods and attributes.</li>\n<li>\n<strong>MagicMock:</strong> Use when you need to mock an object that relies heavily on magic\u00a0methods.</li>\n</ul>\n<h3>When to Use Mock vs. MagicMock</h3>\n<p><strong>Use </strong><strong>Mock\u00a0when:</strong></p>\n<ul>\n<li>You are testing interactions with standard methods and attributes.</li>\n<li>You want more control over what is mocked and avoid unintended behavior from automatically mocked magic\u00a0methods.</li>\n</ul>\n<p><strong>Use </strong><strong>MagicMock when:</strong></p>\n<ul>\n<li>You need to mock an object that uses magic methods extensively (e.g., objects implementing custom behavior for operations like __add__, __getitem__, etc.).</li>\n<li>You prefer convenience and reduced boilerplate for setting up such\u00a0mocks.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ecadf1f1013c\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]},{"title":"Demystifying System Design: What It Is and Why It Matters?","pubDate":"2024-03-23 03:32:34","link":"https://medium.com/@snehagiranje05/demystifying-system-design-what-it-is-and-why-it-matters-59d9cd892a30?source=rss-fcc1a302fb6e------2","guid":"https://medium.com/p/59d9cd892a30","author":"Snehagiranje","thumbnail":"","description":"\n<p>In the realm of technology, especially in software development and engineering, the term \u201csystem design\u201d often emerges in discussions about creating efficient and scalable solutions. But what exactly is system design, and why is it so crucial in today\u2019s digital landscape? Let\u2019s delve into this topic to unravel its significance and understand its impact on modern technology.</p>\n<h3>What is System\u00a0Design?</h3>\n<p>System design is the process of defining the architecture, components, modules, interfaces, and data for a system to meet specified requirements. It involves a deep understanding of the problem domain, technical expertise, and the ability to make informed decisions about design trade-offs. Essentially, system design focuses on creating robust, scalable, and maintainable solutions that address real-world challenges effectively.</p>\n<h3>The Importance of System\u00a0Design</h3>\n<ol>\n<li>Scalability: One of the primary reasons system design is essential is scalability. As businesses grow and user bases expand, systems must be able to handle increased loads without compromising performance. A well-designed system can scale horizontally or vertically, accommodating growing demands seamlessly.</li>\n<li>Reliability: System failures can have significant consequences, leading to downtime, data loss, and negative user experiences. Through thoughtful design, redundancy, fault tolerance mechanisms, and disaster recovery strategies can be incorporated to enhance system reliability.</li>\n<li>Performance: Performance optimization is another critical aspect of system design. By carefully considering algorithms, data structures, caching mechanisms, and efficient resource utilization, systems can deliver fast response times and superior user experiences.</li>\n<li>Flexibility: A well-designed system is flexible and adaptable to evolving requirements and technological advancements. Modular architectures, decoupled components, and standardized interfaces enable easier maintenance, updates, and integration with new functionalities.</li>\n<li>Security: System design plays a crucial role in ensuring data security and privacy. By implementing robust authentication, authorization, encryption, and security best practices, systems can mitigate risks and protect sensitive information from unauthorized access or breaches.</li>\n<li>Cost-Effectiveness: Efficient system design can lead to cost savings in terms of infrastructure resources, maintenance efforts, and operational expenses. By optimizing resource usage, minimizing bottlenecks, and streamlining processes, organizations can achieve higher efficiency and profitability.</li>\n</ol>\n<h3>Real-Life Example: Traffic Management System</h3>\n<p>To illustrate the concept of system design in a relatable way, let\u2019s consider a traffic management system. Imagine a city with multiple intersections, each with traffic lights, pedestrian crossings, and vehicle sensors. A well-designed traffic management system would\u00a0involve:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/844/1*d_uPOZf0McueORVCpY5ZGg.jpeg\"></figure><ul>\n<li>Architecture: The system\u2019s architecture would include centralized control units for traffic lights and sensors, connected through a network to monitor and manage traffic\u00a0flow.</li>\n<li>Components: Traffic lights, pedestrian signals, vehicle sensors, and control algorithms are key components designed to work together seamlessly.</li>\n<li>Interfaces: Standardized interfaces between components allow for efficient communication and coordination, ensuring smooth traffic\u00a0flow.</li>\n<li>Scalability: The system should be scalable to handle increasing traffic volumes during peak hours or special events without causing congestion or\u00a0delays.</li>\n<li>Reliability: Redundancy measures, backup power systems, and fault tolerance mechanisms ensure that the system operates reliably even during unexpected failures or\u00a0outages.</li>\n<li>Performance: Optimization of signal timings, real-time data processing, and adaptive control algorithms improve overall system performance, reducing wait times and optimizing traffic\u00a0flow.</li>\n<li>Security: Access controls, encryption protocols, and intrusion detection systems protect the system from unauthorized access, tampering, or cyber-attacks.</li>\n</ul>\n<p>By applying sound system design principles to a traffic management system, cities can achieve efficient traffic flow, reduce congestion, improve safety, and enhance overall transportation experiences for residents and commuters.</p>\n<h3>Conclusion</h3>\n<p>In conclusion, system design is a fundamental aspect of technology development, encompassing architectural decisions, performance optimizations, scalability considerations, security measures, and more. It is the foundation upon which reliable, scalable, and efficient systems are built, enabling businesses and organizations to innovate, adapt to changes, and deliver exceptional user experiences. Embracing good system design practices is crucial for success in today\u2019s dynamic and competitive digital landscape.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=59d9cd892a30\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>In the realm of technology, especially in software development and engineering, the term \u201csystem design\u201d often emerges in discussions about creating efficient and scalable solutions. But what exactly is system design, and why is it so crucial in today\u2019s digital landscape? Let\u2019s delve into this topic to unravel its significance and understand its impact on modern technology.</p>\n<h3>What is System\u00a0Design?</h3>\n<p>System design is the process of defining the architecture, components, modules, interfaces, and data for a system to meet specified requirements. It involves a deep understanding of the problem domain, technical expertise, and the ability to make informed decisions about design trade-offs. Essentially, system design focuses on creating robust, scalable, and maintainable solutions that address real-world challenges effectively.</p>\n<h3>The Importance of System\u00a0Design</h3>\n<ol>\n<li>Scalability: One of the primary reasons system design is essential is scalability. As businesses grow and user bases expand, systems must be able to handle increased loads without compromising performance. A well-designed system can scale horizontally or vertically, accommodating growing demands seamlessly.</li>\n<li>Reliability: System failures can have significant consequences, leading to downtime, data loss, and negative user experiences. Through thoughtful design, redundancy, fault tolerance mechanisms, and disaster recovery strategies can be incorporated to enhance system reliability.</li>\n<li>Performance: Performance optimization is another critical aspect of system design. By carefully considering algorithms, data structures, caching mechanisms, and efficient resource utilization, systems can deliver fast response times and superior user experiences.</li>\n<li>Flexibility: A well-designed system is flexible and adaptable to evolving requirements and technological advancements. Modular architectures, decoupled components, and standardized interfaces enable easier maintenance, updates, and integration with new functionalities.</li>\n<li>Security: System design plays a crucial role in ensuring data security and privacy. By implementing robust authentication, authorization, encryption, and security best practices, systems can mitigate risks and protect sensitive information from unauthorized access or breaches.</li>\n<li>Cost-Effectiveness: Efficient system design can lead to cost savings in terms of infrastructure resources, maintenance efforts, and operational expenses. By optimizing resource usage, minimizing bottlenecks, and streamlining processes, organizations can achieve higher efficiency and profitability.</li>\n</ol>\n<h3>Real-Life Example: Traffic Management System</h3>\n<p>To illustrate the concept of system design in a relatable way, let\u2019s consider a traffic management system. Imagine a city with multiple intersections, each with traffic lights, pedestrian crossings, and vehicle sensors. A well-designed traffic management system would\u00a0involve:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/844/1*d_uPOZf0McueORVCpY5ZGg.jpeg\"></figure><ul>\n<li>Architecture: The system\u2019s architecture would include centralized control units for traffic lights and sensors, connected through a network to monitor and manage traffic\u00a0flow.</li>\n<li>Components: Traffic lights, pedestrian signals, vehicle sensors, and control algorithms are key components designed to work together seamlessly.</li>\n<li>Interfaces: Standardized interfaces between components allow for efficient communication and coordination, ensuring smooth traffic\u00a0flow.</li>\n<li>Scalability: The system should be scalable to handle increasing traffic volumes during peak hours or special events without causing congestion or\u00a0delays.</li>\n<li>Reliability: Redundancy measures, backup power systems, and fault tolerance mechanisms ensure that the system operates reliably even during unexpected failures or\u00a0outages.</li>\n<li>Performance: Optimization of signal timings, real-time data processing, and adaptive control algorithms improve overall system performance, reducing wait times and optimizing traffic\u00a0flow.</li>\n<li>Security: Access controls, encryption protocols, and intrusion detection systems protect the system from unauthorized access, tampering, or cyber-attacks.</li>\n</ul>\n<p>By applying sound system design principles to a traffic management system, cities can achieve efficient traffic flow, reduce congestion, improve safety, and enhance overall transportation experiences for residents and commuters.</p>\n<h3>Conclusion</h3>\n<p>In conclusion, system design is a fundamental aspect of technology development, encompassing architectural decisions, performance optimizations, scalability considerations, security measures, and more. It is the foundation upon which reliable, scalable, and efficient systems are built, enabling businesses and organizations to innovate, adapt to changes, and deliver exceptional user experiences. Embracing good system design practices is crucial for success in today\u2019s dynamic and competitive digital landscape.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=59d9cd892a30\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":[]}]}